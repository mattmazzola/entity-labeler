{"version":3,"sources":["components/EntityLabeler/withEditModes.ts","components/EntityLabeler/customCommands.ts","components/EntityLabeler/utilities.ts","components/EntityLabeler/elements.tsx","components/EntityLabeler/Toolbar.tsx","components/EntityLabeler/index.ts","components/EntityLabeler/EntityLabeler.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["EditMode","defaultEditorValue","type","children","text","localStorageKey","CustomEditor","isBoldMarkActive","editor","Editor","nodes","match","n","bold","universal","isCodeBlockActive","toggleBoldMark","isActive","Transforms","setNodes","Text","isText","split","toggleCodeBlock","isBlock","saveValue","serializedValue","value","JSON","stringify","serialize","localStorage","setItem","loadValue","string","getItem","parse","expandSelectionToTokenBoundaries","selection","anchor","focus","Point","isAfter","startPoint","endPoint","startTokenPath","path","slice","endTokenPath","startToken","Node","get","endToken","setSelection","offset","length","console","log","wrapNodes","Leaf","props","attributes","className","leaf","CodeElement","ParagraphElement","EntityElement","TokenElement","DefaultElement","defaultEditMode","None","editModeOperationsMaps","LabelMode","Toolbar","onEditModeChange","event","newEditMode","target","editMode","React","useEffect","debug","htmlFor","id","onChange","defaultChecked","name","Boolean","onClick","setValue","EntityLabeler","useMemo","editorWithModes","originalApply","apply","operation","operationType","includes","withEditModes","withReact","withHistory","createEditor","useState","renderElement","useCallback","element","renderLeaf","onMouseUp","newValue","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.fa77a317.chunk.js","sourcesContent":["import { Editor } from \"slate\"\r\n\r\nexport enum EditMode {\r\n    None = 'None',\r\n    LabelMode = 'NoTextEdit',\r\n}\r\n\r\nconst defaultEditMode = EditMode.None\r\n\r\nexport type EditModesEditor = {\r\n    editMode: EditMode\r\n    debug: boolean\r\n}\r\n\r\nconst editModeOperationsMaps: Record<EditMode, string[]> = {\r\n    [EditMode.None]: [],\r\n    [EditMode.LabelMode]: ['insert_text', 'remove_text', 'split_node', 'merge_node'],\r\n}\r\n\r\nexport function withEditModes<T extends Editor>(editor: T): T & EditModesEditor {\r\n    // TODO: Clean up typing. Do we need casting?\r\n    const editorWithModes = (editor as unknown) as (T & EditModesEditor)\r\n    editorWithModes.editMode = defaultEditMode\r\n    editorWithModes.debug = false\r\n\r\n    const { apply: originalApply } = editor\r\n\r\n    editor.apply = (operation) => {\r\n        console.log({\r\n            editMode: editorWithModes.editMode,\r\n            debug: editorWithModes.debug,\r\n            operationType: operation.type,\r\n            operation\r\n        })\r\n\r\n        const disallowedOperaions = editModeOperationsMaps[editorWithModes.editMode]\r\n        const isOperationDisallowed = disallowedOperaions.includes(operation.type)\r\n        if (isOperationDisallowed) {\r\n            return\r\n        }\r\n\r\n        originalApply(operation)\r\n    }\r\n\r\n    return editorWithModes\r\n}","import { Transforms, Editor, Text, Node, Point } from 'slate'\r\nimport { serialize, deserialize } from './utilities'\r\n\r\nexport const defaultEditorValue: Node[] = [\r\n    {\r\n        type: 'paragraph',\r\n        children: [\r\n            {\r\n                type: 'start_token',\r\n                children: [\r\n                    {\r\n                        text: ''\r\n                    },\r\n                ]\r\n            },\r\n            {\r\n                type: 'token',\r\n                children: [\r\n                    {\r\n                        text: 'Token 1'\r\n                    },\r\n                ]\r\n            },\r\n            {\r\n                type: 'token',\r\n                children: [\r\n                    {\r\n                        text: 'Token 2'\r\n                    },\r\n                ]\r\n            },\r\n            {\r\n                type: 'token',\r\n                children: [\r\n                    {\r\n                        text: 'Token 3'\r\n                    },\r\n                ]\r\n            },\r\n            {\r\n                type: 'token',\r\n                children: [\r\n                    {\r\n                        text: 'Token 4'\r\n                    },\r\n                ]\r\n            },\r\n            {\r\n                type: 'end_token',\r\n                children: [\r\n                    {\r\n                        text: ''\r\n                    },\r\n                ]\r\n            },\r\n        ],\r\n    },\r\n]\r\n\r\nconst localStorageKey = 'content'\r\n\r\nconst CustomEditor = {\r\n    isBoldMarkActive(editor: Editor) {\r\n        const [match] = Editor.nodes(editor, {\r\n            match: n => n.bold === true,\r\n            universal: true,\r\n        })\r\n\r\n        return !!match\r\n    },\r\n\r\n    isCodeBlockActive(editor: Editor) {\r\n        const [match] = Editor.nodes(editor, {\r\n            match: n => n.type === 'code',\r\n        })\r\n\r\n        return !!match\r\n    },\r\n\r\n    toggleBoldMark(editor: Editor) {\r\n        const isActive = CustomEditor.isBoldMarkActive(editor)\r\n        Transforms.setNodes(\r\n            editor,\r\n            { bold: isActive ? null : true },\r\n            { match: n => Text.isText(n), split: true }\r\n        )\r\n    },\r\n\r\n    toggleCodeBlock(editor: Editor) {\r\n        const isActive = CustomEditor.isCodeBlockActive(editor)\r\n        Transforms.setNodes(\r\n            editor,\r\n            { type: isActive ? null : 'code' },\r\n            { match: n => Editor.isBlock(editor, n) }\r\n        )\r\n    },\r\n\r\n    saveValue(editor: Editor) {\r\n        const value = editor.children\r\n        // Save the value to Local Storage.\r\n        const serializedValue = serialize(value)\r\n        localStorage.setItem(localStorageKey, serializedValue)\r\n    },\r\n\r\n    loadValue(): Node[] {\r\n        try {\r\n            return deserialize(localStorage.getItem(localStorageKey)!)\r\n                ?? defaultEditorValue\r\n        }\r\n        catch {\r\n            return defaultEditorValue\r\n        }\r\n    },\r\n\r\n    expandSelectionToTokenBoundaries(editor: Editor) {\r\n        const { selection, children } = editor\r\n\r\n        if (!selection?.anchor || !selection?.focus) {\r\n            return\r\n        }\r\n\r\n        const [startPoint, endPoint] = Point.isAfter(selection.anchor, selection.focus)\r\n            ? [selection.focus, selection.anchor]\r\n            : [selection.anchor, selection.focus]\r\n\r\n        const startTokenPath = startPoint.path.slice(0, -1)\r\n        const endTokenPath = endPoint.path.slice(0, -1)\r\n        const startToken = Node.get(editor, startTokenPath)\r\n        const endToken = Node.get(editor, endTokenPath)\r\n\r\n        // If either the start or end is not a token preven expansion\r\n        if (startToken.type !== 'token'\r\n            || endToken.type !== 'token') {\r\n            return\r\n        }\r\n\r\n        Transforms.setSelection(editor, {\r\n            anchor: {\r\n                offset: 0,\r\n                path: startPoint.path\r\n            },\r\n            focus: {\r\n                offset: (Node.get(editor, endPoint.path).text as string).length,\r\n                path: endPoint.path\r\n            }\r\n        })\r\n        console.log({ startToken, endToken })\r\n    },\r\n\r\n    wrapNodes(editor: Editor) {\r\n        Transforms.wrapNodes(editor, { type: 'entity', children: [] })\r\n    }\r\n}\r\n\r\nexport default CustomEditor","import { Node } from 'slate'\r\n\r\n// Define a serializing function that takes a value and returns a string.\r\nexport const serialize = (value: Node[]) => {\r\n    return JSON.stringify(value)\r\n}\r\n\r\nexport const serializeAsString = (value: Node[]) => {\r\n    return (\r\n        value\r\n            // Return the string content of each paragraph in the value's children.\r\n            .map(n => Node.string(n))\r\n            // Join them all with line breaks denoting paragraphs.\r\n            .join('\\n')\r\n    )\r\n}\r\n\r\n// Define a deserializing function that takes a string and returns a value.\r\nexport const deserialize = (string: string): Node[] => {\r\n    return JSON.parse(string)!\r\n}\r\n\r\nexport const deserializeString = (string: string): Node[] => {\r\n    // Return a value array of children derived by splitting the string.\r\n    return string.split('\\n').map(line => {\r\n        return {\r\n            children: [{ text: line }],\r\n        }\r\n    })\r\n}","import React from 'react'\r\nimport { RenderElementProps, RenderLeafProps } from 'slate-react'\r\nimport './Elements.css'\r\n\r\nexport const Leaf: React.FC<RenderLeafProps> = (props) => {\r\n    return (\r\n        <span\r\n            {...props.attributes}\r\n            className={`${props.leaf.bold ? 'leaf-bold' : ''}`}\r\n        >\r\n            {props.children}\r\n        </span>\r\n    )\r\n}\r\n\r\nexport const CodeElement = (props: RenderElementProps) => {\r\n    return (\r\n        <pre {...props.attributes}>\r\n            <code>{props.children}</code>\r\n        </pre>\r\n    )\r\n}\r\n\r\nexport const ParagraphElement = (props: RenderElementProps) => {\r\n    return <div\r\n        {...props.attributes}\r\n        className=\"paragraph\"\r\n    >\r\n        {props.children}\r\n    </div>\r\n}\r\n\r\nexport const EntityElement = (props: RenderElementProps) => {\r\n    return <div\r\n        {...props.attributes}\r\n        className=\"entity\"\r\n    >\r\n        {props.children}\r\n    </div>\r\n}\r\n\r\nexport const TokenElement = (props: RenderElementProps) => {\r\n    return <div {...props.attributes} className=\"token\">{props.children}</div>\r\n}\r\n\r\nexport const DefaultElement = (props: RenderElementProps) => {\r\n    return <div {...props.attributes} className=\"element\">{props.children}</div>\r\n}","import React from 'react'\r\nimport { Editor, Node } from 'slate'\r\nimport CustomEditor, { defaultEditorValue } from './customCommands'\r\nimport { EditMode, EditModesEditor } from './withEditModes'\r\n\r\ntype Props = {\r\n    editor: Editor & EditModesEditor,\r\n    setValue: React.Dispatch<React.SetStateAction<Node[]>>\r\n}\r\nconst Toolbar: React.FC<Props> = (props) => {\r\n    function onEditModeChange(event: React.ChangeEvent<HTMLInputElement>) {\r\n        const newEditMode = event.target.value as EditMode\r\n        props.editor.editMode = newEditMode\r\n        // TODO: Why doesn't useEffect work for this type of state change?\r\n        // Maybe because it's not real react state, and thus the change to an editor property isn't observed?\r\n        console.log({ editMode: props.editor.editMode })\r\n    }\r\n\r\n    React.useEffect(() => {\r\n        console.log(`Change: `, { editMode: props.editor.editMode })\r\n    }, [props.editor.editMode, props.editor.debug])\r\n\r\n    function onChangeDebug() {\r\n        props.editor.debug = !props.editor.debug\r\n    }\r\n\r\n    return (\r\n        <div className=\"toolbar\">\r\n            <fieldset>\r\n                <legend>Mode:</legend>\r\n                <label htmlFor=\"editMode-none\">\r\n                    <input id=\"editMode-none\" onChange={onEditModeChange} type=\"radio\" value={EditMode.None} defaultChecked={props.editor.editMode === EditMode.None} name=\"editMode\" />\r\n                    None\r\n                </label>\r\n                <label htmlFor=\"editMode-noTextEdit\">\r\n                    <input id=\"editMode-noTextEdit\" onChange={onEditModeChange} type=\"radio\" value={EditMode.LabelMode} name=\"editMode\" />\r\n                    Label\r\n                </label>\r\n            </fieldset>\r\n\r\n            <fieldset>\r\n                <legend>Options</legend>\r\n                <label htmlFor=\"editMode-debug\">\r\n                    <input type=\"checkbox\" onChange={onChangeDebug} defaultChecked={Boolean(props.editor.debug)} />\r\n                    Debug\r\n                </label>\r\n            </fieldset>\r\n\r\n            <fieldset>\r\n                <legend>Actions:</legend>\r\n                <button type=\"button\" onClick={() => CustomEditor.wrapNodes(props.editor)}>Wrap Nodes</button>\r\n                <button type=\"button\" onClick={() => CustomEditor.saveValue(props.editor)} >Save</button>\r\n                <button type=\"button\" onClick={() => props.setValue(CustomEditor.loadValue())}>Load</button>\r\n                <button type=\"button\" onClick={() => props.setValue(defaultEditorValue)}>Reset</button>\r\n            </fieldset>\r\n\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default Toolbar","import EntityLabeler from './EntityLabeler'\r\n\r\nexport default EntityLabeler","import React from 'react'\r\nimport { createEditor, Node } from 'slate'\r\nimport { withHistory } from 'slate-history'\r\nimport { Slate, Editable, withReact } from 'slate-react'\r\nimport CustomEditor from './customCommands'\r\nimport { CodeElement, EntityElement, Leaf, ParagraphElement, TokenElement, DefaultElement } from './elements'\r\nimport './EntityLabeler.css'\r\nimport { EditMode, withEditModes } from './withEditModes'\r\nimport Toolbar from './Toolbar'\r\n\r\nconst EntityLabeler: React.FC = () => {\r\n    const editor = React.useMemo(() => withEditModes(withReact(withHistory(createEditor()))), [])\r\n    const [value, setValue] = React.useState(() => CustomEditor.loadValue())\r\n\r\n    const renderElement = React.useCallback(props => {\r\n        switch (props.element.type) {\r\n            case 'paragraph':\r\n                return <ParagraphElement {...props} />\r\n            case 'entity':\r\n                return <EntityElement {...props} />\r\n            case 'token':\r\n                return <TokenElement {...props} />\r\n            case 'code':\r\n                return <CodeElement {...props} />\r\n            default:\r\n                return <DefaultElement {...props} />\r\n        }\r\n    }, [])\r\n\r\n    const renderLeaf = React.useCallback(props => {\r\n        return <Leaf {...props} />\r\n    }, [])\r\n\r\n    const onMouseUp = React.useCallback(event => {\r\n        if (editor.editMode === EditMode.LabelMode) {\r\n            CustomEditor.expandSelectionToTokenBoundaries(editor)\r\n        }\r\n    }, [editor])\r\n\r\n    function onChangeValue(newValue: Node[]) {\r\n        setValue(newValue as any)\r\n    }\r\n\r\n    return (\r\n        <div className=\"entity-labeler\">\r\n            <Toolbar\r\n                editor={editor}\r\n                setValue={setValue}\r\n            />\r\n\r\n            Mode: {editor.editMode}\r\n            Debug: {editor.debug ? 'True' : 'False'}\r\n\r\n            <div className={`slate-container ${editor.debug ? `slate-debug` : ``}`}>\r\n                <Slate\r\n                    editor={editor}\r\n                    value={value}\r\n                    onChange={onChangeValue}\r\n                >\r\n                    <Editable\r\n                        renderElement={renderElement}\r\n                        renderLeaf={renderLeaf}\r\n                        onMouseUp={onMouseUp}\r\n                    />\r\n                </Slate>\r\n            </div>\r\n        </div>\r\n    )\r\n}\r\n\r\n\r\nexport default EntityLabeler","import React from 'react';\nimport './App.css';\nimport EntityLabeler from './components/EntityLabeler'\n\nfunction App() {\n  return (\n    <div className=\"app\">\n      <header>\n        <h1>Entity Labeler</h1>\n        <p>Label hierarchial entities with the new Slate editor</p>\n      </header>\n      <div>\n        <EntityLabeler />\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}